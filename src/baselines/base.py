#!/usr/bin/env python3
"""Shared base classes and result containers for baseline generators."""

from __future__ import annotations

import json
from dataclasses import dataclass, asdict
from pathlib import Path
from typing import Dict, Optional, Tuple

import cv2

from ..threejs_renderer import ThreeJSRenderer, RenderingError

@dataclass
class BaselineResult:
    """Metadata describing artifacts generated by a baseline run."""

    success: bool
    message: str
    html_path: Optional[str] = None
    video_path: Optional[str] = None
    manifest: Optional[Dict[str, str]] = None

    def to_dict(self) -> Dict[str, object]:
        payload = asdict(self)
        payload["manifest"] = self.manifest or {}
        return payload


class BaselineGenerator:
    """Abstract baseline interface."""

    name: str = "baseline"

    def __init__(self, output_root: Path) -> None:
        self.output_root = output_root
        self.artifacts_dir = output_root / "artifacts"
        self.pred_dir = self.artifacts_dir / "predictions" / self.name
        self.video_dir = self.artifacts_dir / "videos" / self.name
        self.log_dir = self.artifacts_dir / "logs" / self.name
        self.frames_dir = self.artifacts_dir / "frames" / self.name
        self.metrics_dir = self.artifacts_dir / "metrics" / self.name
        self.reports_dir = output_root / "reports"
        for folder in (
            self.pred_dir,
            self.video_dir,
            self.log_dir,
            self.frames_dir,
            self.artifacts_dir,
            self.metrics_dir,
            self.reports_dir,
        ):
            folder.mkdir(parents=True, exist_ok=True)
        self._renderer: Optional[ThreeJSRenderer] = None

    def run(
        self,
        dataset_dir: Path,
        video_name: str,
        frame_one: Path,
        frame_ten: Path,
        video_path: Optional[Path],
    ) -> BaselineResult:
        raise NotImplementedError

    # ------------------------------------------------------------------
    # Helper utilities
    # ------------------------------------------------------------------
    def _write_manifest(self, manifest_path: Path, metadata: Dict[str, object]) -> None:
        manifest_path.parent.mkdir(parents=True, exist_ok=True)
        with manifest_path.open("w", encoding="utf-8") as handle:
            json.dump(metadata, handle, ensure_ascii=False, indent=2)

    def _make_output_path(self, suffix: str) -> Path:
        safe_suffix = suffix.strip("/").replace("..", "").replace("/", "_")
        return self.output_root / safe_suffix

    def _ensure_renderer(self) -> ThreeJSRenderer:
        if self._renderer is None:
            self._renderer = ThreeJSRenderer(str(self.output_root))
        return self._renderer

    def _render_html_document(self, html_content: str, video_filename: str) -> Tuple[Optional[Path], Optional[str]]:
        target_path = self.video_dir / video_filename
        try:
            renderer = self._ensure_renderer()
            renderer.render(html_content, str(target_path), content_type="html")
            return target_path, None
        except RenderingError as exc:
            return None, f"{exc}"
        except Exception as exc:
            return None, f"{exc}"

    def _reference_video_meta(self, reference: Optional[Path]) -> Tuple[float, int]:
        default_fps = 15.0
        default_duration_ms = 2000
        if not reference or not reference.exists():
            return default_fps, default_duration_ms
        cap = cv2.VideoCapture(str(reference))
        if not cap.isOpened():
            return default_fps, default_duration_ms
        fps = cap.get(cv2.CAP_PROP_FPS) or 0.0
        frame_count = cap.get(cv2.CAP_PROP_FRAME_COUNT) or 0.0
        cap.release()
        if fps <= 1e-3:
            fps = default_fps
        duration_ms = default_duration_ms
        if frame_count > 0 and fps > 1e-3:
            duration_ms = max(int(round(frame_count * 1000.0 / fps)), 500)
        return float(fps), duration_ms

    def _fill_template(self, template: str, fps: float, duration_ms: int) -> str:
        return (
            template.replace("__TARGET_FPS__", f"{fps:.4f}")
            .replace("__DURATION_MS__", str(duration_ms))
        )


def ensure_frame_paths(
    dataset_dir: Path,
    video_name: str,
    frame_dirs: Optional[list[Path]] = None,
) -> tuple[Optional[Path], Optional[Path]]:
    """Locate frame_01 and frame_10 for a sample."""
    candidates = frame_dirs or [
        dataset_dir / "extracted_frames",
        dataset_dir / "frames",
    ]
    variations = [video_name, video_name.replace(":", "_")]
    for root in candidates:
        if not root.exists():
            continue
        for stem in variations:
            frame_one = root / f"{stem}_frame_01.png"
            frame_ten = root / f"{stem}_frame_10.png"
            if frame_one.exists() and frame_ten.exists():
                return frame_one, frame_ten
    return None, None
